# Zookeeper



## 设计目标

- 1、简单的数据结构，Zookeeper 使得分布式程序能够通过**一个共享的树形结构**的名字空间来进行相互协调，即 Zookeeper 服务器内存中的数据模型**由一系列被称为 ZNode 的数据节点组成**，Zookeeper 将全量的数据**存储在内存中**，以此来提高服务器吞吐、减少延迟的目的。
- 2、可以构建集群，Zookeeper 集群通常由一组机器构成，组成 Zookeeper 集群的**每台机器**都会在**内存**中**维护当前服务器状态**，并且**每台机器之间都相互通信**。
- 3、顺序访问，对于来自客户端的**每个更新请求**，Zookeeper 都会分配一个**全局唯一的递增编号**，这个编号反映了所有事务操作的先后顺序。
- 4、高性能，Zookeeper 和 Redis 一样全量数据存储在内存中，100%读请求压测 QPS 12-13W 







注册与发现。

> 是否有机器加入或退出
>
> 所有机器约定在父目录下创建临时目录节点，然后监听父目录节点下的子节点变化。一旦有机器挂掉，该机器与 ZooKeeper 的**连接断开**，其所创建的**临时目录节点也被删除**，**所有其他机器都收到通知：某个节点被删除了**。

分布式锁。

> 有了 ZooKeeper 的一致性文件系统，锁的问题变得容易。锁服务可以分成两类，一个是**保持独占**，另一个是**控制时序**。
>
> - 1、保持独占，我们把 **znode 看作是一把锁**，通过 createZnode 的方式来实现。所有客户端都去创建 `/distribute_lock` 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的 `/distribute_lock` 节点就释放出锁。
> - 2、控制时序，`/distribute_lock` 已经预先存在，所有**客户端在它下面创建临时顺序编号目录节点**，和 Master 一样，**编号最小的获得锁**，用完删除，依次方便。



队列管理

> 两种类型的队列。
>
> - 1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待。在约定的目录下创建临时目录节点，监听节点数目是否是我们要求的数目。
> - 2、**队列按照 FIFO 方式进行入队和出队操作**。和分布式锁服务中的控制时序的场景基本原理一致，**入列有编号，出列按编号**。创建 PERSISTENT_SEQUENTIAL 节点，创建成功时 Watcher 通知等待的队列，**队列删除序列号最小的节点以消费**。此场景下，znode 用于消息存储，**znode 存储的数据就是消息队列中的消息内容**，SEQUENTIAL 序列号就是消息的编号，按序取出即可。由于创建的节点是**持久化的**，所以不必担心队列消息丢失的问题。









## Zookeeper 提供了什么？

- 1、文件系统。
- 2、通知机制。



## Zookeeper 的文件系统是什么？

Zookeeper 提供一个**多层级的节点命名空间**(节点称为 **znode**)。与文件系统不同的是，**这些节点都可以设置关联的数据**，而文件系统中**只有文件节点可以存放数据**而**目录节点**不行。

Zookeeper 为了**保证高吞吐和低延迟**，**在内存中维护**了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为 **1M** 。





### **Zookeeper 有哪几种节点类型？**

PERSISTENT 持久节点

> 创建之后一直存在，除非有删除操作，创建节点的客户端**会话失效**也不影响此节点。

PERSISTENT_SEQUENTIAL 持久顺序节点

> 跟持久一样，就是父节点在创建下一级子节点的时候，记录每个子节点创建的先后顺序，会给**每个子节点名加上一个数字后缀**。

EPHEMERAL 临时节点

> 创建客户端**会话失效**（**注意是会话失效，不是连接断了**），节点也就没了。不能建子节点。

EPHEMERAL_SEQUENTIAL 临时顺序节点

> 基本特性同临时节点，**增加了顺序属性**，节点名后边会追加一个由父节点维护的自增整型数字。





## Zookeeper 的通知机制是什么？

Zookeeper 允许客户端向服务端的**某个 znode** 注册一个 **Watcher 监听**，当服务端的一些指定事件触发了这个 Watcher ，服务端会向指定客户端发送一个**事件通知**来实现分布式的通知功能，然后**客户端根据 Watcher 通知状态和事件类型做出业务上的改变**



整个流程如下：

- 第一步，客户端注册 Watcher 。
- 第二步，服务端处理 Watcher 。
- 第三步，客户端回调 Watcher 。

Watcher 的特性总结：

1、一次性。

> 无论是服务端还是客户端，**一旦一个 Watcher 被触发**， Zookeeper 都会**将其从相应的存储中移除**。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。

2、客户端串行执行。

> 客户端 Watcher 回调的过程是一个**串行同步的过程**。

3、轻量级 Watch 机制。

> - Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。
> - 客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用`boolean` 类型属性进行了标记

4、Watcher event **异步发送， Watcher 的通知事件**从 Server 发送到Client **是异步的**，这就存在一个问题，不同的客户端和服务器之间通过Socket 进行通信，由于网络延迟或其他因素导致客户端在不同的时刻监听到事件，由于 Zookeeper 本身提供了 ordering guarantee ，即客户端监听事件后，才会感知它所监视 znode 发生了变化。所以我们使用 Zookeeper 不能期望能够监控到节点每次的变化。**Zookeeper 只能保证最终的一致性，而无法保证强一致性**。

5、可以注册 Watcher 的操作：getData、exists、getChildren 。

6、可以触发 Watcher 的操作：create、delete、setData 。

7、当一个 Client 连接到一个新的服务器上时，watch 将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到 watch 的。而当 Client 重新连接时，如果需要的话，所有先前注册过的watch ，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch 可能会丢失：对于一个未创建的 znode 的 exists watch ，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个 watch 事件可能会被丢失。