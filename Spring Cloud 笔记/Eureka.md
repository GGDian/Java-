## Eureka

Eureka由两个组件组成：Eureka服务器和Eureka客户端

在Eureka平台中，如果**某台服务器宕机**，Eureka不会有类似于**ZooKeeper的选举leader**的过程；客户端请求会自动**切换到新的Eureka节点**；当宕机的服务器重新恢复后，Eureka**会再次**将其**纳入**到**服务器集群管理**之中；而对于它来说，所有要做的无非是**同步一些新的服务注册信息**而已。

Eureka内置了**心跳服务**，用于**淘汰一些“濒死”**的服务器；如果在Eureka中注册的服务，它的**“心跳”变得迟缓**时，Eureka会将**其整个剔除出**管理范围（这点有点像ZooKeeper的做法）

如果 Ereaka Server 在**一段时间内**没有接受到**某个微服务示例的心跳**，便会**注销该实例**（**默认90秒**）



如果Eureka服务节点在**短时间里丢失了大量的心跳连接**（注：可能发生了网络故障），那么这个Eureka节点会进入**”自我保护模式“**，同时保留那些**“心跳死亡“的服务注册信息不过期**。此时，这个Eureka节点**对于新的服务还能提供注册服务**，**对于”死亡“的仍然保留**，以防还有客户端向其发起请求。当网络故障恢复后，这个Eureka节点会退出”自我保护模式“。

一旦进入到该模式，Eureka server 就会**保护服务注册表中的信息**，不再删除服务注册表中的数据（即不会注销任何微服务）

那么**即使你关闭了指定实例**，仍然会发现该 Ereaka Server 的注册实例中会**存在被关闭的实例信息**

### 重启 Eureka Server

通常而言，`PRD` 环境建议对 Eureka Server 做负载均衡，这样在依次关闭并开启 Eureka Server 后，无效的实例会被清除，并且不会对正常的使用造成影响。

### 关闭 Eureka 的自我保护模式

在yml配置文件中新增如下配置：

```yml
eureka:
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 4000 # This is not required
```

Eureka还有**客户端缓存功能**

Eureka分为客户端程序与服务器端程序两个部分，客户端程序负责向外提供注册与发现服务接口

即便**Eureka集群中所有节点都失效**，Eureka服务的消费者仍然可以通过**Eureka客户端缓存**来获取现有的**服务注册信息**。

**相对与ZooKeeper**来说剔除了**Leader节点的选取或者事务日志机制**，这样做有利于减少使用者维护的难度也保证了Eureka的在运行时的健壮性



### **服务下线 Cancel**：

官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：`DiscoveryManager.getInstance().shutdownComponent();`

### **获取注册列表信息 Fetch Registries**：

官方解释：`Eureka` 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。**该注册列表信息定期（每30秒钟）更新一次**。每次返回注册列表信息可能与 `Eureka` 客户端的缓存信息不同, `Eureka` 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，`Eureka` 客户端则会重新获取整个注册表信息。 `Eureka` 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。`Eureka` 客户端和 `Eureka` 服务器可以使用JSON / XML格式进行通讯。**在默认的情况下 `Eureka` 客户端使用压缩 `JSON` 格式来获取注册列表的信息**。



# eureka缓存细节以及生产环境的最佳配置

