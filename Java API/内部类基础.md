内部类作为外部类的一个成员，并且依附于外部类而存在的。
内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。



内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。使用内部类最吸引人的原因是：



每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

## 成员内部类

* 成员内部类中，不能定义静态成员
* 成员内部类中，可以访问外部类的所有成员

* 内部类和外部类的实例变量可以共存



在内部类中访问外部类中与内部类同名的实例变量用**外部类名.this.变量名**

如果内部类中**没有与外部类同名的变量**，则可以**直接用变量名**访问外部类变量



* 必须使用此外围类的一个对象来创建其内部类的一个对象

  因此，除非你已经有了外围类的一个对象，否则不可能生成内部类的对象。

* ```
  Outer.Inner outin = out.new Inner()
  ```



内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类

对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。



## 局部内部类

与局部变量类似，局部内部类不能有访问说明符，因为它不是外围类的一部分，**但是它可以访问当前代码块内的常量，和此外围类所有的成员**

如果内部类没有与外部类同名的变量，**在内部类中可以直接访问外部类的实例变量**

可以访问外部类的**局部变量**(即**方法内的变量**)，**但是变量必须是final的**

如果内部类中**有与外部类同名的变量**，直接用**变量名**访问的是**内部类的变量**

用**外部类名.this.内部类变量名**访问的是**外部类变量**



## 静态内部类(嵌套类)

如果你**不需要**内部类对象与其**外围类对象**之间有联系，那你可以将**内部类声明为static**。**这通常称为嵌套类**（nested class）。

普通的内部类对象隐含地保存了一个引用，**指向创建它的外围类对象**。

**不能**从嵌套类的对象中**访问非静态的外围类对象**。

要创建嵌套类的对象，并不需要其外围类的对象。



* 静态内部类可以用**public,protected,private**修饰
* 静态内部类中可以**定义静态或者非静态**的成员
* 静态内部类**只能**访问外部类的静态成员(包括静态变量和静态方法)
* 静态内部类**不能访问**外部类的**非静态成员**(包括非静态变量和非静态方法)
* 外部类访问内部类的静态成员：**内部类.静态成员**
* 外部类访问内部类的非静态成员：**实例化内部类即可**
* **静态内部类的对象可以直接生成**：Outer.Inner in = **new Outer.Inner();** 而不需要通过生成外部类对象来生成。这样实际上使**静态内部类成为了一个顶级类**(正常情况下，你不能在接口内部放置任何代码，但**嵌套类可以作为接口的一部分**，**因为它是static 的**。只是将嵌套类置于接口的命名空间内，这并不违反接口的规则）
  

