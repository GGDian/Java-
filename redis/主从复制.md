* Redis 使用**异步复制**，slave 和 master 之间**异步地确认处理的数据量**
* Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。
* **复制**在 slave 侧大部分也是**非阻塞的**。当 slave 进行初次同步时，它可以**使用旧数据集处理查询**请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会**返回一个 error 给客户端**。
* 但是，**在初次同步之后，旧数据集必须被删除**，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），**会阻塞到来的连接请求**。自 Redis 4.0 开始，可以配置 Redis 使**删除旧数据集**的操作**在另一个不同的线程**中进行，但是，加载新数据集的操作**依然需要**在主线程中进行并且会**阻塞 slave** 。
* 可以**使用复制**来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 **master Redis.conf** 以**避免对磁盘进行持久化**，然后连接一个 slave ，**其配置为不定期保存或是启用 AOF**。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。

### 当 master 关闭持久化时，复制的安全性

当 **Redis Sentinel 被用于高可用并且 master 关闭持久化**，这时如果**允许自动重启进程也是很危险的。**例如， master 可以重启的足够快以致于 Sentinel 没有探测到故障，因此上述的故障模式也会发生。

任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用。

## Redis 复制功能是如何工作的

每一个 Redis master 都有**一个** replication ID ：这是一个较大的伪随机字符串，标记了**一个给定的数据集**。每个 master 也**持有一个偏移量**，master 将**自己产生的复制流发送给 slave 时，发送多少个字节的数据，自身的偏移量就会增加多少**，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的

> Replication ID, offset

都会**标识一个 master 数据集的确切版本**。

当 slave 连接到 master 时，**它们使用 PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。**通过这种方式， master 能够仅发送 slave 所需的**增量部分**。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），**则会转而进行一个全量重同步**：在这种情况下， slave 会得到一个完整的数据集副本，从头开始。

下面是一个全量同步的工作细节：

master 开启一个**后台保存进程**，以便于生产一个 **RDB** 文件。同时它开始**缓冲**所有从客户端接收到的新的写入命令。当后台保存完成时， **master 将数据集文件传输给 slave**， slave将之保存在磁盘上，然后**加载文件到内存**。再然后 master 会发送所有缓冲的命令发给 slave。





## 配置

配置基本的 Redis 复制功能是很简单的：只需要将以下内容加进 slave 的配置文件：

> slaveof 192.168.1.1 6379

当然你需要用你自己的 master IP 地址（或者主机名）和端口替换掉 192.168.1.1 6379。另一种方法，你也可以使用 [SLAVEOF](https://redis.io/commands/slaveof) 命令， master 会开启一个跟 slave 间的同步。

还有一些参数用于调节内存中保存的**缓冲积压部分**（replication backlog），以便执行部分重同步。

**无磁盘复制**可以使用 repl-diskless-sync 配置参数。repl-diskless-sync-delay 参数可以延迟启动数据传输，目的可以在第一个 slave就绪后，等待更多的 slave就绪。



## 允许只写入 N 个附加的副本

从Redis 2.8开始，只有当至少有 N 个 slave 连接到 master 时，才有可能配置 Redis master 接受写查询。

但是，由于 Redis 使用异步复制，因此无法确保 slave 是否实际接收到给定的写命令，因此总会有一个数据丢失窗口。

以下是该特性的工作原理：

- Redis slave **每秒**钟都会 **ping** master，确认已处理的复制流的数量。
- Redis master 会记得上一次从每个 **slave 都收到 ping** 的时间。
- **用户可以配置一个最小的 slave 数量，使得它滞后 <= 最大秒数。**

如果至少有 N 个 slave ，并且滞后小于 M 秒，则写入将被接受。

你可能认为这是一个尽力而为的数据安全机制，对于给定的写入来说，不能保证一致性，但至少数据丢失的时间窗限制在给定的秒数内。一般来说，绑定的数据丢失比不绑定的更好。

如果条件不满足，master 将会回复一个 error 并且写入将不被接受。

这个特性有两个配置参数：

- min-slaves-to-write <slave 数量>
- min-slaves-max-lag <秒数>

## Redis 复制如何处理 key 的过期

* slave 不会让 key 过期，而是**等待 master 让 key 过期**。当一个 master 让一个 key 到期（或由于 LRU 算法将之驱逐）时，它会**合成一个 DEL 命令并传输到所有的 slave**。
* 但是，由于这是 **master 驱动的 key 过期行为**，master 无法及时提供 DEL 命令，所以**有时候 slave 的内存中仍然可能存在在逻辑上已经过期的 key** 。为了处理这个问题，slave 使用它的逻辑时钟以报告只有在不违反数据集的一致性的读取操作（从主机的新命令到达）中才存在 key。用这种方法，**slave 避免报告逻辑过期的 key 仍然存在。**在实际应用中，使用 slave 程序进行缩放的 HTML 碎片缓存，将避免返回已经比期望的时间更早的数据项。
* 在Lua脚本执行期间，不执行任何 key 过期操作。当一个Lua脚本运行时，从概念上讲，master 中的时间是被冻结的，这样脚本运行的时候，一个给定的键要么存在要么不存在。这可以防止 key 在脚本中间过期，保证将相同的脚本发送到 slave ，从而在二者的数据集中产生相同的效果。

## 重新启动和故障转移后的部分重同步

从 Redis 4.0 开始，**当一个实例在故障转移后被提升为 master 时，它仍然能够与旧 master 的 slaves 进行部分重同步。**为此，**slave 会记住旧 master 的旧 replication ID 和复制偏移量**，因此即使询问旧的 replication ID，其也可以将部分复制缓冲提供给连接的 slave 。

但是，升级的 slave 的新 replication ID 将不同，因为它构成了数据集的不同历史记录。例如，master 可以返回可用，并且可以在一段时间内继续接受写入命令，因此在被提升的 slave 中使用相同的 replication ID 将违反一对复制标识和偏移对只能标识单一数据集的规则。

另外，slave 在关机并重新启动后，能够在 RDB 文件中存储所需信息，以便与 master 进行重同步。这在升级的情况下很有用。当需要时，最好使用 SHUTDOWN 命令来执行 slave 的保存和退出操作。





## 内存分配

为了存储用户数据,当设置了maxmemory后Redis会分配几乎和maxmemory一样大的内存

* **当某些缓存被删除后Redis并不是总是立即将内存归还给操作系统。**这并不是redis所特有的，而是函数malloc()的特性。例如你缓存了5G的数据，然后删除了2G数据，从操作系统看，redis可能仍然占用了5G的内存（这个内存叫RSS,后面会用到这个概念），即使redis已经明确声明只使用了3G的空间。这是因为redis使用的底层内存分配器不会这么简单的就把内存归还给操作系统，可能是因为已经删除的key和没有删除的key在同一个页面（page）,这样就不能把完整的一页归还给操作系统.
* 因为这些，当redis的peak内存非常高于平时的内存使用时，碎片所占可用内存的比例就会波动很大。当前使用的内存除以实际使用的物理内存（RSS）就是fragmentation；因为RSS就是peak memory，所以当大部分key被释放的时候，此时内存的`mem_used / RSS`就比较高.
* 如果 `maxmemory` 没有设置，**redis就会一直向OS申请内存**，直到OS的所有内存都被使用完。

* 设置了maxmemory后，当redis的内存达到内存限制后，再向redis发送写指令，会返回一个内存耗尽的错误。错误通常会触发一个应用程序错误，但是不会导致整台机器宕掉.



