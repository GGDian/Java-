## string (字符串)

Redis 的字符串是**动态字符串**，是**可以修改**的字符串，内部结构实现上类似于 **Java 的 ArrayList**，采用**预分配冗余空间**的方式来减少内存的频繁分配。内部为当前字符串实际分配的空间 **capacity** 一般要**高于**实际字符串长度 **len**。当字符串长度**小于 1M** 时，扩容都是**加倍现有**的空间，如果**超过 1M**，扩容时一次**只会多扩 1M** 的空间。需要注意的是字符串**最大长度为 512M**。

自增是**有范围的**，它的范围是 **signed long** 的**最大（9223372036854775807）最小值**，超过了这个值，Redis 会报错。

字符串是由**多个字节**组成，每个字节又是由 **8 个 bit** 组成，如此便可以将**一个字符串**看成很多 bit 的组合，这便是 **bitmap「位图」数据结构**

## list (列表)

Redis 的列表相当于 Java 语言里面的 **LinkedList**，注意它是链表而不是数组

**插入和删除**操作非常快，时间复杂度为 **O(1)**，但是**索引定位**很慢，时间复杂度为 **O(n)**

**慢操作**

lindex 相当于 Java 链表的`get(int index)`方法，它需要对**链表进行遍历**，性能随着参数`index`增大而变差。

ltrim 跟的两个参数`start_index`和`end_index`定义了一个区间，在这个区间内的值，ltrim 要保留

index 可以为负数，`index=-1`表示倒数第一个元素，同样`index=-2`表示倒数第二个元素



Redis 底层存储的还不是一个简单的 `linkedlist`，而是称之为**快速链表** `quicklist` 的一个结构

![image-20200423131057330](C:\Users\垫\AppData\Roaming\Typora\typora-user-images\image-20200423131057330.png)

首先在列表元素较少的情况下会**使用一块连续的内存存储**，这个结构是 `ziplist`，也即是**压缩列表**。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 `quicklist`。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 `int` 类型的数据，结构上还需要两个额外的指针 `prev` 和 `next` 。所以 Redis 将链表和 `ziplist` 结合起来组成了 `quicklist`。也就是将多个 `ziplist` 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。



## hash (字典)

Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的**数组 + 链表二维结构**。

Redis 的字典的值只能是字符串

Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。

渐进式 rehash 会在 rehash 的同时，**保留新旧两个 hash 结构**，查询时会**同时查询**两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，**循序渐进地**将旧 hash 的内容一点点迁移到新的 hash 结构中

## set (集合)

它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值`NULL`。

当集合中最后一个元素移除之后，数据结构自动删除，**内存被回收**。

## zset (有序集合)

内部实现用的是一种叫做**「跳跃列表」**的数据结构

`score` 值可以是**整数值或双精度浮点数**。

zset 中最后一个 value 被移除后，数据结构自动删除，**内存被回收**。

因为 zset 要支持随机的插入和删除，所以它不好使用数组来表示

跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。

![image-20200423132536731](C:\Users\垫\AppData\Roaming\Typora\typora-user-images\image-20200423132536731.png)

首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L31 层。绝大多数元素都过不了几层，**只有极少数元素可以深入到顶层**。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。



## 容器型数据结构的通用规则

list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：

1. create if not exists

   如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。

2. drop if no elements

   如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。



## 队列延迟

 blpop/brpop

这两个指令的前缀字符`b`代表的是`blocking`，也就是阻塞读。

阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用`blpop/brpop`替代前面的`lpop/rpop`，就完美解决了上面的问题。

## 空闲连接自动断开

**空闲连接**的问题

如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候`blpop/brpop`会抛出异常来

## 锁冲突处理

我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办

1. 直接抛出异常，通知用户稍后重试；
2. sleep 一会再重试；
3. 将请求转移至延时队列，过一会再试；

**直接抛出特定类型的异常**

这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。

**sleep**

sleep 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，sleep 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。

**延时队列**

这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。

## 延时队列的实现

延时队列可以通过 Redis 的 **zset(有序列表)** 来实现。我们将消息序列化成一个字符串作为 zset 的`value`，这个消息的到期处理时间作为`score`，然后用**多个线程轮询 zset 获取到期的任务进行处理**，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以**需要考虑并发争抢任务**，**确保任务不能被多次执行**。



# 应用 3：节衣缩食 —— 位图

位图不是特殊的数据结构，它的内容其实就是**普通的字符串**，也就是 **byte 数组**。

我们可以使用普通的 **get/set** 直接获取和设置整个位图的内容，也可以**使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理**。

## 基本使用

Redis 的**位数组是自动扩展**，如果**设置了某个偏移位置超出了现有的内容范围**，就会**自动将位数组进行零扩充**。

## 统计和查找

Redis 提供了位图统计指令 **bitcount 和位图查找指令 bitpos**，**bitcount** 用来统计指定位置范围内 **1 的个数**，**bitpos** 用来**查找指定范围**内出现的第一个 0 或 1。

比如我们可以通过 **bitcount 统计用户一共签到了多少天**，通过 **bitpos 指令**查找用户**从哪一天开始**第一次签到。如果**指定了范围参数`[start, end]`**，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。

start 和 end 参数是**字节索引**，也就是说指定的**位范围必须是 8 的倍数**

```redis
127.0.0.1:6379> set w hello
OK
127.0.0.1:6379> bitcount w
(integer) 21
127.0.0.1:6379> bitcount w 0 0  # 第一个字符中 1 的位数
(integer) 3
127.0.0.1:6379> bitcount w 0 1  # 前两个字符中 1 的位数
(integer) 7
127.0.0.1:6379> bitpos w 0  # 第一个 0 位
(integer) 0
127.0.0.1:6379> bitpos w 1  # 第一个 1 位
(integer) 1
127.0.0.1:6379> bitpos w 1 1 1  # 从第二个字符算起，第一个 1 位
(integer) 9
127.0.0.1:6379> bitpos w 1 2 2  # 从第三个字符算起，第一个 1 位
(integer) 17
```

# 应用 4：四两拨千斤 —— HyperLogLog

Redis 提供了 **HyperLogLog** 数据结构就是用来解决这种**统计问题**的。HyperLogLog **提供不精确的去重计数方案**，虽然不精确但是也不是非常不精确，**标准误差是 0.81%**，这样的精确度已经可以满足上面的 UV 统计需求了

## 使用方法

HyperLogLog 提供了两个指令 **pfadd 和 pfcount**，根据字面意义很好理解，一个是**增加计数**，一个是**获取计数**。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。

```
127.0.0.1:6379> pfadd codehole user1
(integer) 1
127.0.0.1:6379> pfcount codehole
(integer) 1
127.0.0.1:6379> pfadd codehole user2
(integer) 1
127.0.0.1:6379> pfcount codehole
(integer) 2
```

## pfmerge 适合什么场合用？

HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。

## 注意事项

HyperLogLog 这个数据结构不是免费的，不是说使用这个数据结构要花钱，它需要占据一定 **12k** 的存储空间，所以它不适合统计单个用户相关的数据。如果你的用户上亿，可以算算，这个空间成本是非常惊人的。

因为 Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间。

# 应用 5：层峦叠嶂 —— 布隆过滤器

当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。